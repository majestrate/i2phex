<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0069)http://www.limewire.com/developer/query_routing/keyword%20routing.htm -->
<HTML xmlns="http://www.w3.org/TR/REC-html40" xmlns:v = 
"urn:schemas-microsoft-com:vml" xmlns:o = 
"urn:schemas-microsoft-com:office:office" xmlns:w = 
"urn:schemas-microsoft-com:office:word"><HEAD><TITLE>Protocols:</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content=Word.Document name=ProgId>
<META content="MSHTML 5.50.4913.1100" name=GENERATOR>
<META content="Microsoft Word 9" name=Originator><LINK 
href="./keyword%20routing_files/filelist.xml" rel=File-List><LINK 
href="./keyword%20routing_files/editdata.mso" rel=Edit-Time-Data><LINK 
href="./keyword%20routing_files/oledata.mso" rel=OLE-Object-Data><!--[if !mso]>
<STYLE>v\:* {
	BEHAVIOR: url(#default#VML)
}
o\:* {
	BEHAVIOR: url(#default#VML)
}
w\:* {
	BEHAVIOR: url(#default#VML)
}
.shape {
	BEHAVIOR: url(#default#VML)
}
</STYLE>
<![endif]--><!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>crohrs</o:Author>
  <o:Template>Normal</o:Template>
  <o:LastAuthor>crohrs</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>90</o:TotalTime>
  <o:LastPrinted>2001-05-02T15:58:00Z</o:LastPrinted>
  <o:Created>2002-05-16T18:17:00Z</o:Created>
  <o:LastSaved>2002-05-16T18:17:00Z</o:LastSaved>
  <o:Pages>17</o:Pages>
  <o:Words>5202</o:Words>
  <o:Characters>29653</o:Characters>
  <o:Company>Dell Computer Corporation</o:Company>
  <o:Lines>247</o:Lines>
  <o:Paragraphs>59</o:Paragraphs>
  <o:CharactersWithSpaces>36415</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:ActiveWritingStyle Lang="EN-US" VendorID="64" DLLVersion="131077"
   NLCheck="1">1</w:ActiveWritingStyle>
  <w:ActiveWritingStyle Lang="EN-US" VendorID="64" DLLVersion="131078"
   NLCheck="1">1</w:ActiveWritingStyle>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]-->
<STYLE>@font-face {
	font-family: Wingdings;
}
@font-face {
	font-family: Tahoma;
}
@font-face {
	font-family: TIMES NEW \(W1\);
}
@page  {mso-endnote-separator: url("./keyword%20routing_files/header.htm") es; }
@page Section1 {size: 8.5in 11.0in; margin: 1.0in 1.25in 1.0in 1.25in; mso-header-margin: .5in; mso-footer-margin: .5in; mso-paper-source: 0; }
P.MsoNormal {
	FONT-SIZE: 12pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Times New Roman"; mso-style-parent: ""; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
LI.MsoNormal {
	FONT-SIZE: 12pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Times New Roman"; mso-style-parent: ""; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
DIV.MsoNormal {
	FONT-SIZE: 12pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Times New Roman"; mso-style-parent: ""; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
H1 {
	FONT-SIZE: 16pt; MARGIN: 12pt 0in 3pt; FONT-FAMILY: Arial; mso-pagination: widow-orphan; mso-style-next: Normal; mso-outline-level: 1; mso-font-kerning: 16.0pt
}
H2 {
	FONT-SIZE: 14pt; MARGIN: 12pt 0in 3pt; FONT-STYLE: italic; FONT-FAMILY: Arial; mso-pagination: widow-orphan; mso-style-next: Normal; mso-outline-level: 2
}
H3 {
	FONT-SIZE: 12pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Times New Roman"; mso-pagination: widow-orphan; mso-style-next: Normal; mso-outline-level: 3
}
H4 {
	FONT-SIZE: 14pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: Arial; mso-pagination: widow-orphan; mso-style-next: Normal; mso-outline-level: 4
}
H5 {
	FONT-SIZE: 12pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Times New Roman"; TEXT-ALIGN: center; mso-pagination: widow-orphan; mso-style-next: Normal; mso-outline-level: 5
}
H6 {
	FONT-SIZE: 12pt; MARGIN: 0in 0in 0pt; FONT-STYLE: italic; FONT-FAMILY: "Times New Roman"; TEXT-ALIGN: center; mso-pagination: widow-orphan; mso-style-next: Normal; mso-outline-level: 6
}
P.MsoFootnoteText {
	FONT-SIZE: 10pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Times New Roman"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
LI.MsoFootnoteText {
	FONT-SIZE: 10pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Times New Roman"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
DIV.MsoFootnoteText {
	FONT-SIZE: 10pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Times New Roman"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
P.MsoCommentText {
	FONT-SIZE: 10pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Times New Roman"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
LI.MsoCommentText {
	FONT-SIZE: 10pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Times New Roman"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
DIV.MsoCommentText {
	FONT-SIZE: 10pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Times New Roman"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
P.MsoCaption {
	FONT-WEIGHT: bold; FONT-SIZE: 10pt; MARGIN: 6pt 0in; FONT-FAMILY: "Times New Roman"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"; mso-style-next: Normal
}
LI.MsoCaption {
	FONT-WEIGHT: bold; FONT-SIZE: 10pt; MARGIN: 6pt 0in; FONT-FAMILY: "Times New Roman"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"; mso-style-next: Normal
}
DIV.MsoCaption {
	FONT-WEIGHT: bold; FONT-SIZE: 10pt; MARGIN: 6pt 0in; FONT-FAMILY: "Times New Roman"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"; mso-style-next: Normal
}
SPAN.MsoFootnoteReference {
	VERTICAL-ALIGN: super
}
SPAN.MsoCommentReference {
	mso-ansi-font-size: 8.0pt; mso-bidi-font-size: 8.0pt
}
SPAN.MsoEndnoteReference {
	VERTICAL-ALIGN: super
}
P.MsoEndnoteText {
	FONT-SIZE: 10pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Times New Roman"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
LI.MsoEndnoteText {
	FONT-SIZE: 10pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Times New Roman"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
DIV.MsoEndnoteText {
	FONT-SIZE: 10pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Times New Roman"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
P.MsoBodyText {
	FONT-SIZE: 12pt; MARGIN: 0in 0in 0pt; FONT-STYLE: italic; FONT-FAMILY: "Times New Roman"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
LI.MsoBodyText {
	FONT-SIZE: 12pt; MARGIN: 0in 0in 0pt; FONT-STYLE: italic; FONT-FAMILY: "Times New Roman"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
DIV.MsoBodyText {
	FONT-SIZE: 12pt; MARGIN: 0in 0in 0pt; FONT-STYLE: italic; FONT-FAMILY: "Times New Roman"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
A:link {
	COLOR: blue; TEXT-DECORATION: underline; text-underline: single
}
SPAN.MsoHyperlink {
	COLOR: blue; TEXT-DECORATION: underline; text-underline: single
}
A:visited {
	COLOR: purple; TEXT-DECORATION: underline; text-underline: single
}
SPAN.MsoHyperlinkFollowed {
	COLOR: purple; TEXT-DECORATION: underline; text-underline: single
}
P.MsoDocumentMap {
	FONT-SIZE: 12pt; BACKGROUND: navy; MARGIN: 0in 0in 0pt; FONT-FAMILY: Tahoma; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
LI.MsoDocumentMap {
	FONT-SIZE: 12pt; BACKGROUND: navy; MARGIN: 0in 0in 0pt; FONT-FAMILY: Tahoma; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
DIV.MsoDocumentMap {
	FONT-SIZE: 12pt; BACKGROUND: navy; MARGIN: 0in 0in 0pt; FONT-FAMILY: Tahoma; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
P.MsoPlainText {
	FONT-SIZE: 10pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Courier New"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
LI.MsoPlainText {
	FONT-SIZE: 10pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Courier New"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
DIV.MsoPlainText {
	FONT-SIZE: 10pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Courier New"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"
}
P.CommentSubject {
	FONT-WEIGHT: bold; FONT-SIZE: 10pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Times New Roman"; mso-style-parent: "Comment Text"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"; mso-style-next: "Comment Text"; mso-style-name: "Comment Subject"
}
LI.CommentSubject {
	FONT-WEIGHT: bold; FONT-SIZE: 10pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Times New Roman"; mso-style-parent: "Comment Text"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"; mso-style-next: "Comment Text"; mso-style-name: "Comment Subject"
}
DIV.CommentSubject {
	FONT-WEIGHT: bold; FONT-SIZE: 10pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: "Times New Roman"; mso-style-parent: "Comment Text"; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"; mso-style-next: "Comment Text"; mso-style-name: "Comment Subject"
}
P.BalloonText {
	FONT-SIZE: 8pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: Tahoma; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"; mso-style-name: "Balloon Text"
}
LI.BalloonText {
	FONT-SIZE: 8pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: Tahoma; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"; mso-style-name: "Balloon Text"
}
DIV.BalloonText {
	FONT-SIZE: 8pt; MARGIN: 0in 0in 0pt; FONT-FAMILY: Tahoma; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman"; mso-style-name: "Balloon Text"
}
DIV.Section1 {
	page: Section1
}
OL {
	MARGIN-BOTTOM: 0in
}
UL {
	MARGIN-BOTTOM: 0in
}
</STYLE>
<!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="2050"/>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]--></HEAD>
<BODY lang=EN-US style="tab-interval: .5in" vLink=purple link=blue>
<DIV class=Section1>
<H1 style="TEXT-ALIGN: center" align=center>Query Routing for the Gnutella 
Network</H1>
<P class=MsoNormal style="TEXT-ALIGN: center" align=center>Version 1.0</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal style="TEXT-ALIGN: center" align=center><I>Christopher 
Rohrs<o:p></o:p></I></P>
<P class=MsoNormal style="TEXT-ALIGN: center" align=center><I><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>Lime Wire LLC<o:p></o:p></I></P>
<P class=MsoNormal style="TEXT-ALIGN: center" align=center><I>May 16, 
2002<o:p></o:p></I></P>
<H5 style="TEXT-ALIGN: left" 
align=left><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></H5>
<TABLE 
style="BORDER-RIGHT: medium none; BORDER-TOP: medium none; MARGIN-LEFT: 41.4pt; BORDER-LEFT: medium none; BORDER-BOTTOM: medium none; BORDER-COLLAPSE: collapse; mso-border-alt: solid windowtext .5pt; mso-padding-alt: 0in 5.4pt 0in 5.4pt" 
cellSpacing=0 cellPadding=0 border=1>
  <TBODY>
  <TR>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: windowtext 0.5pt solid; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: windowtext 0.5pt solid; WIDTH: 387pt; PADDING-TOP: 0in; BORDER-BOTTOM: medium none" 
    vAlign=top width=516 colSpan=2>
      <H5>Document History</H5>
      <P 
      class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P></TD></TR>
  <TR>
    <TD 
    style="BORDER-RIGHT: medium none; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: windowtext 0.5pt solid; WIDTH: 27pt; PADDING-TOP: 0in; BORDER-BOTTOM: medium none" 
    vAlign=top width=36>
      <P class=MsoNormal>1.0</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 5in; PADDING-TOP: 0in; BORDER-BOTTOM: medium none" 
    vAlign=top width=480>
      <P class=MsoNormal>Added binary examples in the appendix.</P>
      <P class=MsoNormal>Documented endian values.</P>
      <P class=MsoNormal>Function code of ROUTE_TABLE_UPDATE is 0x30, not 
      0x20.</P>
      <P 
      class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P></TD></TR>
  <TR>
    <TD 
    style="BORDER-RIGHT: medium none; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: windowtext 0.5pt solid; WIDTH: 27pt; PADDING-TOP: 0in; BORDER-BOTTOM: medium none" 
    vAlign=top width=36>
      <P class=MsoNormal>0.5</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 5in; PADDING-TOP: 0in; BORDER-BOTTOM: medium none" 
    vAlign=top width=480>
      <P class=MsoNormal>Incorporated Willem Broekema’s comments from </P>
      <P class=MsoNormal><A 
      href="http://groups.yahoo.com/group/the_gdf/message/4735">http://groups.yahoo.com/group/the_gdf/message/4735</A></P>
      <P class=MsoNormal>Added warning about QRP propagation.</P>
      <P 
      class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P></TD></TR>
  <TR>
    <TD 
    style="BORDER-RIGHT: medium none; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: windowtext 0.5pt solid; WIDTH: 27pt; PADDING-TOP: 0in; BORDER-BOTTOM: medium none" 
    vAlign=top width=36>
      <P class=MsoNormal>0.4</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 5in; PADDING-TOP: 0in; BORDER-BOTTOM: medium none" 
    vAlign=top width=480>
      <P class=MsoNormal>Used integer hash function.<SPAN 
      style="mso-spacerun: yes">&nbsp; </SPAN></P>
      <P class=MsoNormal>Incorporated corrections from Vinnie Falco.</P>
      <P 
      class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P></TD></TR>
  <TR>
    <TD 
    style="BORDER-RIGHT: medium none; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: windowtext 0.5pt solid; WIDTH: 27pt; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid" 
    vAlign=top width=36>
      <P class=MsoNormal>0.3</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 5in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid" 
    vAlign=top width=480>
      <P class=MsoNormal>First public version.</P></TD></TR></TBODY></TABLE>
<P class=MsoNormal style="TEXT-ALIGN: center" align=center><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal style="TEXT-ALIGN: center" align=center><I><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></I></P>
<TABLE 
style="BORDER-RIGHT: medium none; BORDER-TOP: medium none; MARGIN-LEFT: 41.4pt; BORDER-LEFT: medium none; BORDER-BOTTOM: medium none; BORDER-COLLAPSE: collapse; mso-border-alt: solid windowtext .5pt; mso-padding-alt: 0in 5.4pt 0in 5.4pt" 
cellSpacing=0 cellPadding=0 border=1>
  <TBODY>
  <TR>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: windowtext 0.5pt solid; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: windowtext 0.5pt solid; WIDTH: 387pt; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid" 
    vAlign=top width=516>
      <H6><SPAN style="FONT-STYLE: normal">Important Note<o:p></o:p></SPAN></H6>
      <P class=MsoNormal style="TEXT-ALIGN: center" align=center><B><I><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></I></B></P>
      <P class=MsoNormal>Since this document was originally written, the 
      LimeWire client has introduced <I>ultrapeers</I>,<I> </I>which offload 
      most messaging to high capacity hosts <A title="" 
      style="mso-endnote-id: edn1" name=_ednref1 
      href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_edn1"><SPAN 
      class=MsoEndnoteReference>[Sin]</SPAN></A>. Ultrapeers use a subset of the 
      query routing proposal.<SPAN style="mso-spacerun: yes">&nbsp;&nbsp; 
      </SPAN>In particular leaf nodes send query route table update messages to 
      ultrapeers, but ultrapeers never propogate these tables.<SPAN 
      style="mso-spacerun: yes">&nbsp; </SPAN>We advise authors of Gnutella 
      clients to implement the ultrapeer protocol using query routing but 
      <I>without table propogation</I>.<SPAN style="mso-spacerun: yes">&nbsp; 
      </SPAN>Developers<I> </I>should concentrate on Section 4 of this document, 
      “Gnutella Protocol Changes”, as well as the examples in the appendix.</P>
      <P 
      class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
      <P class=MsoNormal>While full-fledged query routing may work well, 
      understanding the effects of query routing between ultrapeers requires 
      more study.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>There is 
      potential for much harm if used carelessly.</P></TD></TR></TBODY></TABLE>
<P class=MsoNormal style="TEXT-ALIGN: center" align=center><I><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></I></P>
<P class=MsoNormal style="TEXT-ALIGN: center" align=center><I><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></I></P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in"><B>Abstract</B><I>: We present a 
novel scheme for avoiding broadcast queries on the Gnutella network.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>In this scheme, hosts create query route 
tables by hashing file keywords and regularly exchange them with their 
neighbors.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Standard compression 
techniques minimize the cost of exchanging tables. Our scheme could dramatically 
reduce Gnutella’s bandwidth requirements, though careful study and simulation is 
needed before widespread deployment.</I></P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<H2>Introduction</H2>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>The Gnutella protocol uses broadcasts to query for 
files.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>A back-of-the-envelope 
calculation shows that this quickly limits the number of hosts that can be 
searched.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Despite popular rumor, 
this does not necessarily limit the overall size of the network <A title="" 
style="mso-endnote-id: edn2" name=_ednref2 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_edn2"><SPAN 
class=MsoEndnoteReference>[Bil]</SPAN></A>.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Still, it is clearly desirable to 
eliminate broadcast queries.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>Reducing query traffic increases scalability and leaves more bandwidth 
for uploads and downloads.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Many ideas have been proposed to eliminate broadcasts.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Freenet, for example, avoids broadcasts 
through a clever lexical routing scheme <A title="" style="mso-endnote-id: edn3" 
name=_ednref3 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_edn3"><SPAN 
class=MsoEndnoteReference>[Lan]</SPAN></A>.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>However, this scheme is imperfect.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>First, it requires you to know the exact 
name of the file you wish to download.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>For example, “constitution.txt” will not match “constitution.html”.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Secondly, it only returns a single match 
for your query.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Users searching for 
“book” are bound to be disappointed.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Recently Prinkey presented a clever scheme for routing 
queries based on keywords <A title="" style="mso-endnote-id: edn4" name=_ednref4 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_edn4"><SPAN 
class=MsoEndnoteReference>[Pri]</SPAN></A>.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>The idea behind this scheme is to have 
hosts periodically exchange keyword route tables with their neighbors.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>To reduce bandwidth, Prinkey describes 
an efficient way of encoding these keywords through hashing and bitmaps.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>The result is that queries are normally 
only sent to hosts that can respond to them.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Furthermore, Prinkey’s scheme does not 
suffer from any of Freenet’s problems.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>Unfortunately it requires organizing the network in a tree-like 
fashion.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>This paper generalizes Prinkey’s routing scheme for use on 
the Gnutella network.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Our key ideas 
are to include distance information in routing tables and to compress the tables 
with well-known algorithms.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>First 
we review Prinkey’s original keyword-based routing scheme.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Then we describe the changes that are 
necessary for non-tree networks.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>Next, we propose a new Gnutella message for this purpose.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>We also discuss hashing in some 
depth.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Finally we conclude with 
remarks about the effects of this routing scheme on the network.</P>
<P class=MsoNormal><SPAN style="mso-spacerun: yes"></SPAN>&nbsp;</P>
<H2>Prinkey’s Scheme</H2>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>This section reviews Prinkey’s query routing scheme for 
rooted tree topologies.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>We present 
this scheme through an example and a series of refinements.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Readers familiar with the scheme may 
choose to skip to the next section.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Consider four hosts in a tree-like hierarchy rooted at host 
A, as shown below.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Hosts B, C, and 
D are serving files named “bad joke”, “good book”, and “good joke”, 
respectively.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>For simplicity assume 
that only node A is interested in querying the network.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>With Gnutella’s current search scheme, 
any query from A must be sent to all of the other hosts.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>For example, a query for “bad joke” will 
needlessly be sent to hosts C and D.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>This is inefficient.</P>
<P class=MsoNormal style="TEXT-ALIGN: center" align=center><A name=OLE_LINK1><!--[if gte vml 1]><v:shapetype id=_x0000_t75 coordsize = 
"21600,21600" o:preferrelative = "t" o:spt = "75" filled = "f" stroked = "f" 
path = " m@4@5 l@4@11@9@11@9@5 xe"><v:stroke joinstyle = 
"miter"></v:stroke><v:formulas><v:f eqn = 
"if lineDrawn pixelLineWidth 0 "></v:f><v:f eqn = "sum @0 1 0 "></v:f><v:f eqn = 
"sum 0 0 @1 "></v:f><v:f eqn = "prod @2 1 2 "></v:f><v:f eqn = 
"prod @3 21600 pixelWidth "></v:f><v:f eqn = 
"prod @3 21600 pixelHeight "></v:f><v:f eqn = "sum @0 0 1 "></v:f><v:f eqn = 
"prod @6 1 2 "></v:f><v:f eqn = "prod @7 21600 pixelWidth "></v:f><v:f eqn = 
"sum @8 21600 0 "></v:f><v:f eqn = "prod @7 21600 pixelHeight "></v:f><v:f eqn = 
"sum @10 21600 0 "></v:f></v:formulas><v:path o:extrusionok = "f" 
gradientshapeok = "t" o:connecttype = "rect"></v:path><o:lock v:ext="edit" 
aspectratio = "t"></o:lock></v:shapetype><v:shape id=_x0000_i1025 
style="WIDTH: 167.25pt; HEIGHT: 222.75pt" o:ole="" type = "#_x0000_t75" 
coordsize = "21600,21600" o:allowoverlap = "f"><v:imagedata o:title="" src = 
"./keyword%20routing_files/image001.wmz"></v:imagedata></v:shape><![endif]--><![if !vml]><img border=0 width=223 height=297
src="./keyword%20routing_files/image002.gif" v:shapes="_x0000_i1025"><![endif]><!--[if gte mso 9]><xml>
 <o:OLEObject Type="Embed" ProgID="MSDraw.Drawing.8.2" ShapeID="_x0000_i1025"
  DrawAspect="Content" ObjectID="_1083060218">
 </o:OLEObject>
</xml><![endif]--></A></P>
<P class=MsoCaption style="MARGIN-BOTTOM: 0pt; TEXT-ALIGN: center" 
align=center>Figure 1: Route tables in a rooted tree. </P>
<P class=MsoCaption style="MARGIN-TOP: 0in; TEXT-ALIGN: center" 
align=center>Keywords are not hashed for simplicity.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Broadcasts can be avoided if hosts maintain some sort of 
routing table for each connection.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>One possibility is to have hosts propagate all file keywords<A title="" 
style="mso-footnote-id: ftn1" name=_ftnref1 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftn1"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[1]<![endif]></SPAN></SPAN></A> 
up the tree.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>For example, host B 
would know that keywords {“good”, “book”} are reachable through C, and A would 
know that {“good”, “book”, “bad”, “joke”} are (indirectly) reachable through 
B.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>More formally, the routing table 
for a connection to a host X is the union of all routing tables for the 
connections from X to its children.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>This is illustrated above.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>With this information, a query is only sent along a connection if all 
keywords of the query are found in that connection’s routing table.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>For example, a query for “bad joke” 
would be sent from A to B, but not from B to C or D, since neither of these 
connections contains the keyword “bad”.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>Likewise, a query for “good joke” would be sent from A to B to D, but not 
to C.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>(Queries are interpreted as 
logical AND’s of keywords, not OR’s.)</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>This scheme guarantees there are never <I>false 
negatives</I>.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>That is, a query 
will always be sent along a connection if some host reachable via that 
connection can respond to the query.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>However it does not eliminate <I>false positives</I>.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>For example, a query for “joke book” or 
“bad joke” may be sent from A to B even though neither C nor D can respond to 
the query.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>It is hard to avoid 
these false positives, but one can reasonably assume that they are rare.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Propagating route tables can potentially consume a lot of 
bandwidth.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>To solve this problem, 
Prinkey advocates hashing each keyword and storing the resulting numbers in a 
bitmap.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>For example, if “good” 
hashes to 2 and “book” to 5, the routing table for {“good”, “book”} can be 
compressed to the bitmap 001001….<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>Note that the second and fifth bits (starting from zero at the left) are 
set in this bitmap.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>In other words, 
each multibyte string is compressed to a single bit.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>The resulting tables are an example of 
<I style="mso-bidi-font-style: normal">Bloom filters</I>.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Table propagation is done by logically 
OR’ing bitmaps instead of unioning sets of keywords.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Of course there is a chance that two 
strings could hash to the same value, but this only causes harmless false 
positives.<SPAN style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN></P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>However, this scheme has two serious problems.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>First, it requires a tree topology with 
a designated root.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>This is 
difficult to form in a distributed fashion, especially if the tree is to account 
for the underlying structure of the network.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Secondly, if a host other than the root 
wants to query the network, it must send the query up the tree to the root.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>This forces the nodes at the top of the 
tree to handle a disproportionate amount of traffic.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Modifications are needed before this 
scheme can be adopted to Gnutella.<SPAN style="mso-spacerun: yes">&nbsp;&nbsp; 
</SPAN></P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<H2>Routing Without Trees</H2>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>One way of routing queries in a non-tree network like 
Gnutella is to simply propagate route tables along all connections.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>That is, at every time step, a host sets 
its route tables to be the logical OR of its neighbors’ route tables and its own 
files.<A title="" style="mso-footnote-id: ftn2" name=_ftnref2 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftn2"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[2]<![endif]></SPAN></SPAN></A><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>So at after T time steps, all hosts 
within T hops of a host X are aware of X’s files.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>The problem is that X’s routing 
information will continue to propagate long after it has left the network.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>This will dramatically increase the 
false positive rate—resulting in much wasted bandwidth.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>For this reason, it is critical to limit the span of a host’s 
routing information.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>This can be 
done by associating a hops value with each keyword.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Routing tables are now an array of 
numbers instead of an array of bits, where each number is the minimum distance 
to a matching file.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>More formally, 
for any connection C, RT<SUB>C</SUB>[h] is the number of hops to a file with a 
keyword that hashes to h, or infinity if no such file exists.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Note that RT<SUB>C</SUB>[h] &#8805;1, for all 
h.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Queries are forwarded to those 
connections whose route tables have entries for all query keywords.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>That is, a query with TTL N and keywords 
K<SUB>1</SUB>, .., K<SUB>M</SUB> is only sent along a connection C if 
RT<SUB>C</SUB>[HASH(K<SUB>i</SUB>)]&#8804;N, for <I>all</I> 1&lt;i&#8804;M.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN></P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Hosts now update their tables via dynamic programming; at 
every time step, hosts exchange all their tables with neighbors and update them 
accordingly.<A title="" style="mso-footnote-id: ftn3" name=_ftnref3 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftn3"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[3]<![endif]></SPAN></SPAN></A><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Let host X have connections to hosts 
Y<SUB><SPAN 
style="FONT-FAMILY: 'TIMES NEW \(W1\)'; mso-bidi-font-family: 'Times New Roman'">1</SPAN></SUB>…Y<SUB><SPAN 
style="FONT-FAMILY: 'TIMES NEW \(W1\)'; mso-bidi-font-family: 'Times New Roman'">M</SPAN></SUB>.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Let RT<SUB>Yi-&gt;X</SUB> be the route 
table received by X from host Y<SUB>i</SUB>.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>If X is not sharing any files with 
keywords hashing to h, the table RT<SUB>X-&gt;Yi</SUB> propagated by X to each 
host Y<SUB>i</SUB> is given by 
RT<SUB>X-&gt;Yi</SUB>[h]=min<SUB>j&#8800;i</SUB>(RT<SUB>Yj-&gt;X</SUB>[h])+1.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Otherwise, 
RT<SUB>X-&gt;Yi</SUB>[h]=1.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>As an example, consider the network described in the previous 
section.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>The fact that this network 
is a tree is a coincidence; it need not have a root and may have cycles.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>After one time step, hosts have 
exchanged routing tables for files one hops away.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>This is illustrated below on the 
left-hand side. <SPAN style="mso-spacerun: yes">&nbsp;</SPAN>Here sets of 
keywords are shown instead of arrays of hashed values for simplicity.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>For example, the table “{bad/1, joke/2}” 
would really be represented as the array [&#8734;, 2, &#8734;, 1, &#8734;, ...] if “bad” hashed to 
3 and “joke” hashed to 1.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>After a 
second time step, hosts have exchanged routing tables for files two hops 
away.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>This is illustrated below on 
the right-hand side.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Note that A 
now has routing entries for all files. <SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>On the other hand, B is aware that no 
files are reachable through A.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal><!--[if gte vml 1]><v:shape id=_x0000_i1026 
style="WIDTH: 447pt; HEIGHT: 253.5pt" o:ole="" type = "#_x0000_t75" coordsize = 
"21600,21600"><v:imagedata o:title="" src = 
"./keyword%20routing_files/image003.wmz"></v:imagedata></v:shape><![endif]--><![if !vml]><img border=0 width=596 height=338
src="./keyword%20routing_files/image004.gif" v:shapes="_x0000_i1026"><![endif]><!--[if gte mso 9]><xml>
 <o:OLEObject Type="Embed" ProgID="MSDraw.Drawing.8.2" ShapeID="_x0000_i1026"
  DrawAspect="Content" ObjectID="_1083060219">
 </o:OLEObject>
</xml><![endif]--></P>
<P class=MsoCaption style="MARGIN-BOTTOM: 0pt; TEXT-ALIGN: center" 
align=center>Figure 2: Propagation of route tables by TTL.</P>
<P class=MsoCaption style="MARGIN-TOP: 0in; TEXT-ALIGN: center" 
align=center>Keywords are not hashed for simplicity.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>At first this scheme seems wasteful.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Instead of exchanging one bit per 
keyword, hosts exchange a log<SUB>2</SUB>(M) bit number, where M is the maximum 
TTL.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>So with a typical TTL of 10, 
neighbors exchange 4 times more data than in Prinkey’s original scheme.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>However experiments show that 
traditional data compression algorithms can reduce the size of these route 
tables quite substantially.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>As an 
example, a very sparse table (one where most entries are infinity) will have 
almost no information, and hence can be encoded with few bits.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Furthermore, one expects an uneven 
distribution of numbers, which is ideal for certain kinds of statistical 
compression schemes.<A title="" style="mso-footnote-id: ftn4" name=_ftnref4 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftn4"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[4]<![endif]></SPAN></SPAN></A><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Hence we need not design our own 
encoding scheme; this greatly simplifies our update protocol.<A title="" 
style="mso-footnote-id: ftn5" name=_ftnref5 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftn5"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[5]<![endif]></SPAN></SPAN></A></P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>An important question is when to update these tables.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Ideally a host would send a route table 
update after adding or removing connections, or changing its shared file 
list.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>However, several improvements 
can be made that will greatly reduce the amount of bandwidth used.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>First, hosts should only propagate route 
table information from connections that have been up for a few minutes.<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>This means that it may take a few 
minutes for a host to be searchable, but it tends to weed out the majority of 
short-lived connections.<A title="" style="mso-footnote-id: ftn6" name=_ftnref6 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftn6"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[6]<![endif]></SPAN></SPAN></A><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>More importantly, hosts should not send 
out more than one message per connection per T minutes.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>In other words, if a host receives 
several update messages from its neighbors within a T-minute window, they will 
be consolidated into a single message that is forwarded on.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>So the number of update messages sent 
per connection is independent of the network size or the number of the host’s 
connections.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>If the route table RT to be sent to a host is very similar to 
the last table RT’ sent, it may be advantageous to send an incremental 
update.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>First, the sender creates a 
“patch” by subtracting each element of RT and RT’.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Note that this patch contains all zeroes 
if the table has not changed, and positive or negative values otherwise.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Then this patch is compressed as 
discussed above and sent along the connection.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>The receiver then decompresses this 
patch and adds it to the route table for that connection.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>In a relatively stable network, such 
patches may save a considerable amount of bandwidth.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<H2>Gnutella Protocol Changes</H2>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>To implement the above scheme for the Gnutella network, we 
propose the addition of a single extensible message to the protocol, called 
ROUTE_TABLE_UPDATE.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>The proposed 
function code of this message is 0x30, since Gnutella uses even function codes 
for broadcast messages.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>(An earlier 
version of this document incorrectly suggested 0x20; that value was used at 
least experimentally by some versions of BearShare.)</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>ROUTE_TABLE_UPDATE messages come in several variants.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>The length of the payload is defined in 
the Gnutella general message header and must always be at least 1. The first 
byte of the payload determines the message’s variant.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Only two variants are currently defined: 
RESET (0x0) and PATCH (0x1).<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>The 
format of these messages is shown below.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>More variants could be defined later if desired. This allows us to modify 
the route table mechanism without adding new Gnutella function codes.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<TABLE 
style="BORDER-RIGHT: medium none; BORDER-TOP: medium none; BORDER-LEFT: medium none; BORDER-BOTTOM: medium none; BORDER-COLLAPSE: collapse; mso-border-alt: solid windowtext .5pt; mso-padding-alt: 0in 5.4pt 0in 5.4pt" 
cellSpacing=0 cellPadding=0 border=1>
  <TBODY>
  <TR>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: windowtext 0.5pt solid; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: windowtext 0.5pt solid; WIDTH: 1.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid" 
    vAlign=top width=115>
      <P class=MsoNormal><B>Field Name<o:p></o:p></B></P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: windowtext 0.5pt solid; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 0.75in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt" 
    vAlign=top width=72>
      <P class=MsoNormal><B>Bytes<o:p></o:p></B></P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: windowtext 0.5pt solid; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 4.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt" 
    vAlign=top width=403>
      <P class=MsoNormal><B>Meaning<o:p></o:p></B></P></TD></TR>
  <TR>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: windowtext 0.5pt solid; WIDTH: 1.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=115>
      <P class=MsoNormal>VARIANT</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 0.75in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=72>
      <P class=MsoNormal>1</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 4.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=403>
      <P class=MsoNormal>The message variant.<SPAN 
      style="mso-spacerun: yes">&nbsp; </SPAN>Always 0x0 for RESET.</P></TD></TR>
  <TR>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: windowtext 0.5pt solid; WIDTH: 1.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=115>
      <P class=MsoNormal>TABLE_LENGTH</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 0.75in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=72>
      <P class=MsoNormal>4</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 4.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=403>
      <P class=MsoNormal>The length of the sender’s route table, i.e., the 
      number of entries.<I style="mso-bidi-font-style: normal"><SPAN 
      style="mso-spacerun: yes">&nbsp; </SPAN></I>(Earlier versions of this 
      document incorrectly stated the meaning of this value.)<SPAN 
      style="mso-spacerun: yes">&nbsp; </SPAN>For hashing reasons, this <I 
      style="mso-bidi-font-style: normal">must</I> be a power of 2.<SPAN 
      style="mso-spacerun: yes">&nbsp; </SPAN>Little endian.</P></TD></TR>
  <TR>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: windowtext 0.5pt solid; WIDTH: 1.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=115>
      <P class=MsoNormal>INFINITY</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 0.75in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=72>
      <P class=MsoNormal>1</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 4.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=403>
      <P class=MsoNormal>The route table value for infinity, i.e., the maximum 
      distance to any file in the table+1.</P></TD></TR></TBODY></TABLE>
<P class=MsoCaption style="TEXT-ALIGN: center" align=center>Format of the RESET 
variant payload</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<TABLE 
style="BORDER-RIGHT: medium none; BORDER-TOP: medium none; BORDER-LEFT: medium none; BORDER-BOTTOM: medium none; BORDER-COLLAPSE: collapse; mso-border-alt: solid windowtext .5pt; mso-padding-alt: 0in 5.4pt 0in 5.4pt" 
cellSpacing=0 cellPadding=0 border=1>
  <TBODY>
  <TR>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: windowtext 0.5pt solid; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: windowtext 0.5pt solid; WIDTH: 1.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid" 
    vAlign=top width=115>
      <P class=MsoNormal><B>Field Name<o:p></o:p></B></P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: windowtext 0.5pt solid; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 0.75in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt" 
    vAlign=top width=72>
      <P class=MsoNormal><B>Bytes<o:p></o:p></B></P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: windowtext 0.5pt solid; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 4.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt" 
    vAlign=top width=403>
      <P class=MsoNormal><B>Meaning<o:p></o:p></B></P></TD></TR>
  <TR>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: windowtext 0.5pt solid; WIDTH: 1.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=115>
      <P class=MsoNormal>VARIANT</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 0.75in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=72>
      <P class=MsoNormal>1</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 4.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=403>
      <P class=MsoNormal>The message variant.<SPAN 
      style="mso-spacerun: yes">&nbsp; </SPAN>Always 0x1 for PATCH.</P></TD></TR>
  <TR>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: windowtext 0.5pt solid; WIDTH: 1.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=115>
      <P class=MsoNormal>SEQ_NO</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 0.75in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=72>
      <P class=MsoNormal>1</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 4.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=403>
      <P class=MsoNormal>The position of this message in the update 
    sequence.</P></TD></TR>
  <TR>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: windowtext 0.5pt solid; WIDTH: 1.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=115>
      <P class=MsoNormal>SEQ_SIZE</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 0.75in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=72>
      <P class=MsoNormal>1</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 4.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=403>
      <P class=MsoNormal>The total number of messages in this update 
      sequence.</P></TD></TR>
  <TR>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: windowtext 0.5pt solid; WIDTH: 1.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=115>
      <P class=MsoNormal>COMPRESSOR</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 0.75in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=72>
      <P class=MsoNormal>1</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 4.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=403>
      <P class=MsoNormal>The algorithm to use when decompressing data.<SPAN 
      style="mso-spacerun: yes">&nbsp; </SPAN>Currently defined values:</P>
      <P class=MsoNormal style="MARGIN-LEFT: 0.5in">0x0 no compression</P>
      <P class=MsoNormal style="MARGIN-LEFT: 0.5in">0x1 ZLIB 
  compression</P></TD></TR>
  <TR>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: windowtext 0.5pt solid; WIDTH: 1.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=115>
      <P class=MsoNormal>ENTRY_BITS</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 0.75in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=72>
      <P class=MsoNormal>1</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 4.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=403>
      <P class=MsoNormal>The number of bits per uncompressed patch entry, 
      including the sign bit.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Must 
      be 4 or 8.</P></TD></TR>
  <TR>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: windowtext 0.5pt solid; WIDTH: 1.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=115>
      <P class=MsoNormal>DATA</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 0.75in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=72>
      <P class=MsoNormal>to end of payload</P></TD>
    <TD 
    style="BORDER-RIGHT: windowtext 0.5pt solid; PADDING-RIGHT: 5.4pt; BORDER-TOP: medium none; PADDING-LEFT: 5.4pt; PADDING-BOTTOM: 0in; BORDER-LEFT: medium none; WIDTH: 4.2in; PADDING-TOP: 0in; BORDER-BOTTOM: windowtext 0.5pt solid; mso-border-left-alt: solid windowtext .5pt; mso-border-top-alt: solid windowtext .5pt" 
    vAlign=top width=403>
      <P class=MsoNormal>The compressed table patch.</P></TD></TR></TBODY></TABLE>
<P class=MsoCaption style="TEXT-ALIGN: center" align=center>Format of the PATCH 
variant payload</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>A RESET variant must precede any PATCH variants.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>This message resets the receiver’s route 
table to a completely empty table of TABLE_LENGTH elements.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>For hashing reasons discussed below, 
TABLE_LENGTH must be a power of two.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>Each element of this table has a numerical value of INFINITY.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Typically INFINITY is chosen to be one 
greater than the maximum TTL, e.g., 11.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>Hosts may send more RESET messages at any point in the future, e.g., if 
there has been a drastic change in the route table.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>After receiving a RESET message along a 
connection C, a host is encouraged to disregard the route table for C and 
forward all queries along the C until the table has been fully updated via PATCH 
messages.<A title="" style="mso-footnote-id: ftn7" name=_ftnref7 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftn7"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[7]<![endif]></SPAN></SPAN></A><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>This means, for example, that a client 
will broadcast all queries for a few seconds after startup.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>The PATCH variant incrementally changes the receiver’s route 
table in the manner described in the previous section.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>To prepare a patch, the sender first 
subtracts the last route table sent (or INFINITY if no table has been sent) from 
the current route table, yielding an array of signed numbers.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>(Note that the sender must therefore 
store two route tables per connection.)<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>Then the sender interprets this array as a binary string and compresses 
it with a well-known algorithm.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>Finally, the sender chunks this data into PATCH messages and sends these 
messages one-by-one.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Each message 
has a TTL of 1 and hops value of 0, and all messages of the sequence share the 
same SEQ_SIZE, COMPRESSOR, and ENTRY_BITS fields.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>(These are discussed later.)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>The receiver inverts this process to 
update its route table. This is illustrated below.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Several examples of RESET and PATCH 
variants are shown in the appendix.</P>
<P class=MsoNormal style="TEXT-ALIGN: center" 
align=center><!--[if gte vml 1]><v:shape id=_x0000_i1027 
style="WIDTH: 434.25pt; HEIGHT: 166.5pt" o:ole="" type = "#_x0000_t75" coordsize 
= "21600,21600"><v:imagedata o:title="" src = 
"./keyword%20routing_files/image005.wmz"></v:imagedata></v:shape><![endif]--><![if !vml]><img border=0 width=579 height=222
src="./keyword%20routing_files/image006.gif" v:shapes="_x0000_i1027"><![endif]><!--[if gte mso 9]><xml>
 <o:OLEObject Type="Embed" ProgID="MSDraw.Drawing.8.2" ShapeID="_x0000_i1027"
  DrawAspect="Content" ObjectID="_1083060221">
 </o:OLEObject>
</xml><![endif]--></P>
<P class=MsoCaption style="TEXT-ALIGN: center" align=center>Converting route 
tables to PATCH messages</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>One may ask why multiple PATCH messages are sent for each 
table update; an alternative is to send a single giant PATCH every T 
minutes.<SPAN style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>Unfortunately this 
would stall other Gnutella traffic for unacceptable periods of time.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Interleaving PATCH messages with normal 
traffic requires negligible extra bandwidth and decreases the worst-case latency 
of normal queries.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>A maximum 
message size of 1KB might be a good choice.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>This would block query traffic for at 
most 200 ms on a modem with 5KB/s bandwidth.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Clients are encouraged to spread the 
PATCH messages equally over the T minute window if possible.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN></P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>The receiver uses the SEQ_NO and SEQ_SIZE fields to 
reassemble the compressed patch from a sequence of PATCH messages.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>The SEQ_SIZE field is the number of 
PATCH messages in this sequence.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>The SEQ_NO field is the message’s position in the sequence.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Messages in the sequence must be sent 
in-order, so the SEQ_SIZE fields should increase by one in each message of the 
sequence.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>If either of these 
conditions is violated (e.g., because the sender is improperly dropping buffered 
messages<A title="" style="mso-footnote-id: ftn8" name=_ftnref8 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftn8"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[8]<![endif]></SPAN></SPAN></A>), 
the receiver should close the connection; because table updates are generally 
incremental, there is no way to recover from a missing message.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Note that the sequence numbers are 
intended only to provide a “sanity check”, not to make the use of a reliable 
transport layer (i.e., TCP) obsolete.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>For this reason, no provisions are made for sequence restart. The 
sequence is completed when receiving a message whose SEQ_NO==SEQ_SIZE.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Note that sequences are limited to 255 
messages, since only one unsigned byte is used per SEQ_SIZE field.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Also remember that the sender may send a 
RESET message at any time to start a new patch sequence</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Once the receiver has reassembled the compressed patch, it 
must decompress it with the algorithm specified in the COMPRESSOR field.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Currently two algorithms are specified: 
0x0 for no algorithm or 0x1 for the ZLIB algorithm<A title="" 
style="mso-footnote-id: ftn9" name=_ftnref9 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftn9"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[9]<![endif]></SPAN></SPAN></A>.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>All implementations must support these 
algorithms.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>New algorithms could be 
added in the future, though an out-of-band mechanism must be used to discover 
any such additional capabilities.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Decompressing a compressed patch yields a sequence of 
bits.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>The receiver must interpret 
these bits as an array of <I style="mso-bidi-font-style: normal">signed</I> 
numbers in twos complement notation.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>It does so by breaking the bits into elements that are ENTRY_BITS bits 
long.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>The length of the resulting 
patch array must be the same length as the TABLE_SIZE field passed in the latest 
RESET message.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>For simplicity, 
ENTRY_BITS is restricted to 4 or 8.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>For example, the uncompressed string 001011110000 would be interpreted as 
the patch [2, -1, 0] if ENTRY_BITS=4.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>One could argue that a decent compression algorithm should eliminate the 
need vary this value, but our experiments show that setting ENTRY_BITS to 4 when 
possible can reduce table sizes by around 10%.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>In this scheme, table updates are not necessarily 
atomic.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>That is, the receiver need 
not wait until receiving the last PATCH message before modifying or even 
propagating part of its route table for that connection.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>We believe that this is actually a good 
thing.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>First, it reduces the memory 
requirements of the client, as there is no need to buffer received PATCH 
messages.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Second, it may reduce the 
worst-case latency for table propagations.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Older clients present difficulty in any sort of routing 
scheme, as they will not propagate route tables, creating “black holes” in the 
network.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>For example, consider a 
string of clients A-B-X-C.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>If X is 
an older client, queries from A will rarely reach C, though queries from C will 
reach A.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>One option is for B to 
propagate a fake routing table from X with entries for all keywords, but this 
will undo the benefits of routing.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>A better choice is for newer clients to prefer newer clients whenever 
possible.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>This can be implemented 
through host discovery services like <SPAN 
style="FONT-FAMILY: 'Courier New'; mso-bidi-font-family: 'Times New Roman'">router.limewire.com</SPAN>, 
GUID versioning schemes<A title="" style="mso-footnote-id: ftn10" name=_ftnref10 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftn10"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[10]<![endif]></SPAN></SPAN></A>, 
or the Gnutella “0.6” handshaking mechanism <A title="" 
style="mso-endnote-id: edn5" name=_ednref5 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_edn5"><SPAN 
class=MsoEndnoteReference>[Bil2]</SPAN></A>.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Whether or not a client connects to 
older clients—at the cost of wasted bandwidth—should be user configurable.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>In the above example, A connects to X 
only if it wants to search older Gnutella clients.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Note that older clients <I>will</I> be 
able to search new clients.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>This is 
illustrated below.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal style="TEXT-ALIGN: center" 
align=center><!--[if gte vml 1]><v:shape id=_x0000_i1028 
style="WIDTH: 435pt; HEIGHT: 183.75pt" o:ole="" type = "#_x0000_t75" coordsize = 
"21600,21600"><v:imagedata o:title="" src = 
"./keyword%20routing_files/image007.wmz"></v:imagedata></v:shape><![endif]--><![if !vml]><img border=0 width=580 height=245
src="./keyword%20routing_files/image008.gif" v:shapes="_x0000_i1028"><![endif]><!--[if gte mso 9]><xml>
 <o:OLEObject Type="Embed" ProgID="MSDraw.Drawing.8.2" ShapeID="_x0000_i1028"
  DrawAspect="Content" ObjectID="_1083060222">
 </o:OLEObject>
</xml><![endif]--><B><SPAN style="FONT-SIZE: 10pt">Partitioning the network 
into new and old clients</SPAN></B></P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<H2>Hashing Details</H2>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>A query string contains one or more arbitrarily long 
keywords.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>These keywords should be 
separated by the ASCII value for a space (‘ ‘), i.e., the byte 0x20.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>For example, the query string “graphics 
book” contains the keywords “graphics” and “book”.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>A consistent hash function h(k,m) is 
needed to map each keyword string k to an entry of a route table of length 
m.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>This function must satisfy three 
properties:</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<OL style="MARGIN-TOP: 0in" type=1>
  <LI class=MsoNormal style="mso-list: l3 level1 lfo11; tab-stops: list .5in">It 
  hashes keys of arbitrary length reasonably uniformly. 
  <LI class=MsoNormal style="mso-list: l3 level1 lfo11; tab-stops: list .5in">It 
  is implemented easily and efficiently on most platforms. 
  <LI class=MsoNormal style="mso-list: l3 level1 lfo11; tab-stops: list .5in">It 
  allows one to convert between hash tables of different sizes.<SPAN 
  style="mso-spacerun: yes">&nbsp; </SPAN>More formally, given h(k, m) and m—but 
  not k—it is possible to compute h(k, m’) for an arbitrary m’.<SPAN 
  style="mso-spacerun: yes">&nbsp; </SPAN>This allows clients with different 
  route tables to interoperate, an important feature for upwards compatibility. 
  </LI></OL>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Any standard hash function should satisfy the first two 
properties.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>The third property, 
however, is harder to satisfy.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>For 
example, this effectively rules out division methods. i.e., those based on 
congruence modulo m.<SPAN style="mso-spacerun: yes">&nbsp;&nbsp; 
</SPAN>Thankfully other methods will suffice.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>To start, we need a way of converting an 
arbitrary length string k into a 32-bit natural number n.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>We recommend calculating n from k as 
follows:</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal style="TEXT-ALIGN: center" align=center>n = k[3]k[2]k[1]k[0] 
^ k[7]k[6]k[5]k[4] ^ ...</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Here wxyz refers to concatenation of bytes w through z, with 
z being the least significant byte.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>x^y is the logical XOR of bytes x and y.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>In other words, one interprets each 
keyword as a sequence of 32-bit little-endian numbers—&shy;padded with 1 to 3 
zeroes if needed—and XORs the numbers together.</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.25in"><SPAN 
style="mso-spacerun: yes"></SPAN>&nbsp;</P>
<P class=MsoNormal>Now one must map the natural number n onto the range 0 to 
(m-1).<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>While it is not practical, a 
function with the right properties is</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal style="TEXT-ALIGN: center" align=center>h’(n, m) = <SPAN 
style="FONT-FAMILY: Symbol; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-char-type: symbol; mso-symbol-font-family: Symbol"><SPAN 
style="mso-char-type: symbol; mso-symbol-font-family: Symbol">ë</SPAN></SPAN> m 
((n A) mod 1) <SPAN 
style="FONT-FAMILY: Symbol; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-char-type: symbol; mso-symbol-font-family: Symbol"><SPAN 
style="mso-char-type: symbol; mso-symbol-font-family: Symbol">û</SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-ALIGN: center" align=center>where A = 
(&#8730;5-1)/2&#8776;0.6180339887...</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Here <SPAN 
style="FONT-FAMILY: Symbol; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-char-type: symbol; mso-symbol-font-family: Symbol"><SPAN 
style="mso-char-type: symbol; mso-symbol-font-family: Symbol">ë</SPAN></SPAN>x<SPAN 
style="FONT-FAMILY: Symbol; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-char-type: symbol; mso-symbol-font-family: Symbol"><SPAN 
style="mso-char-type: symbol; mso-symbol-font-family: Symbol">û</SPAN></SPAN> 
means the floor of x, and “x mod 1” means the fractional part of<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>x, i.e., x-<SPAN 
style="FONT-FAMILY: Symbol; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-char-type: symbol; mso-symbol-font-family: Symbol"><SPAN 
style="mso-char-type: symbol; mso-symbol-font-family: Symbol">ë</SPAN></SPAN>x<SPAN 
style="FONT-FAMILY: Symbol; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-char-type: symbol; mso-symbol-font-family: Symbol"><SPAN 
style="mso-char-type: symbol; mso-symbol-font-family: Symbol">û</SPAN></SPAN>.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>This function is discussed in depth in 
<I>Introduction to Algorithms</I> by Cormen, Leiserson, and Rivest.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>The value of A is suggested by Knuth to 
avoid collisions for a wide range of data.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>Unfortunately this function is bound to result in different values on 
different platforms because of rounding errors.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN></P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>However, if we restrict m a power of two, the function can be 
computed using integer operations as follows: first one multiplies the 32-bit 
value of n by the 32 bit-constant 0x4F1BBCDC, producing a 64-bit product.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>The hash is then bits 31-b+1 through 31 
of the product, inclusive, where b=log<SUB>2</SUB>(m).<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>(Assume<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>bits are labelled 0 through 63.)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>A Java implementation of this function 
is shown in Appendix A, along with sample outputs.</P>
<P class=MsoNormal><SPAN style="mso-spacerun: yes"></SPAN>&nbsp;</P>
<P class=MsoNormal>It is easy to interpolate/extrapolate this function when 
converting between tables of different sizes.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Assume we wish to interpolate a table T 
of size m to a table T’ of size m’.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>If we visualize the tables as number lines, it becomes clear that an 
element T’[i] should be set to the minimum of all overlapping elements of 
T.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>This is illustrated below, along 
with pseudocode.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Here ‘X’ is the 
symbol for infinity.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>In the 
pseudocode, we assume C-style indices (from 0 to m-1), assume that all elements 
of T’ are initialized to infinity, and assume that T and T’ use the same value 
for infinity.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal style="TEXT-ALIGN: center" 
align=center><!--[if gte vml 1]><v:shape id=_x0000_i1029 
style="WIDTH: 4in; HEIGHT: 100.5pt" o:ole="" type = "#_x0000_t75" coordsize = 
"21600,21600"><v:imagedata o:title="" src = 
"./keyword%20routing_files/image009.wmz"></v:imagedata></v:shape><![endif]--><![if !vml]><img border=0 width=384 height=134
src="./keyword%20routing_files/image010.gif" v:shapes="_x0000_i1029"><![endif]><!--[if gte mso 9]><xml>
 <o:OLEObject Type="Embed" ProgID="MSDraw.Drawing.8.2" ShapeID="_x0000_i1029"
  DrawAspect="Content" ObjectID="_1083060223">
 </o:OLEObject>
</xml><![endif]--></P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">for all i, where 0 &#8804; i &lt; m,</P>
<P class=MsoNormal style="MARGIN-LEFT: 1in">for all i’, where <SPAN 
style="FONT-FAMILY: Symbol; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-char-type: symbol; mso-symbol-font-family: Symbol"><SPAN 
style="mso-char-type: symbol; mso-symbol-font-family: Symbol">ë</SPAN></SPAN> i 
m’/m <SPAN 
style="FONT-FAMILY: Symbol; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-char-type: symbol; mso-symbol-font-family: Symbol"><SPAN 
style="mso-char-type: symbol; mso-symbol-font-family: Symbol">û</SPAN></SPAN> &#8804; 
i’&lt; <SPAN 
style="FONT-FAMILY: Symbol; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-char-type: symbol; mso-symbol-font-family: Symbol"><SPAN 
style="mso-char-type: symbol; mso-symbol-font-family: Symbol">é</SPAN></SPAN>(i+1) 
m’/m<SPAN 
style="FONT-FAMILY: Symbol; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-char-type: symbol; mso-symbol-font-family: Symbol"><SPAN 
style="mso-char-type: symbol; mso-symbol-font-family: Symbol">ù</SPAN></SPAN> 
</P>
<P class=MsoNormal style="MARGIN-LEFT: 1.5in">T’[i’]=min(T’[i’], T[i])</P>
<P class=MsoNormal style="MARGIN-LEFT: 1.5in"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoCaption style="TEXT-ALIGN: center" align=center>Scaling route 
tables.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>‘X’ means infinity.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Current implementations lower-case keywords before adding 
them to route tables and when comparing incoming queries with the tables.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Internationalization presents some 
problems, however.<SPAN style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>Clients 
cannot guess the language of a query, nor can they be expected cannot be 
expected to understand case rules for all languages, e.g. Arabic script.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>There clients should ideally 
canonicalize all keywords in a (human) language-specific manner before adding 
them to route tables or sending them in queries.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>For English, this means ensuring all 
letters are lower case.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Also, note 
that the hash function operates on bytes, not characters.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>This means that all characters must be 
encoded in a unique, canonical manner.<B><I><SPAN 
style="FONT-SIZE: 14pt; FONT-FAMILY: Arial"><o:p></o:p></SPAN></I></B></P>
<H2>Conclusion</H2>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>The key assumption behind routing is that the savings in 
query reduction outweighs the cost of exchanging route tables.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>The size of query routing tables depends 
on two factors: the number of distinct keywords in the horizon and the 
efficiency with which these can be encoded.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>The number of keywords, in turn, depends 
on the number of users within the horizon and the number of distinct items they 
are sharing.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>This latter is 
difficult to estimate.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>However, preliminary evidence suggests that these tables can 
be encoded quite efficiently.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>As an 
experiment, we recorded query replies over several hours and built the routing 
tables corresponding to those replies.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>We found that a 65536 element route table with 12000 keywords and 
INFINITY=7 could be transmitted in just over 12 KB if ENTRY_BITS=4—one byte per 
keyword—or 13 KB if ENTRY_BITS=8.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>As with the existing Gnutella protocol, this scheme limits 
your search radius to N hops.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>That 
is not necessarily a problem.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>Because routing allows you to hold more connections with the same amount 
of bandwidth, the diameter of the network will be greatly decreased.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>In fact, Gnutella may already have a 
“small world” model, meaning that most hosts are reachable through a short 
number of hops.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN></P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Query routing has the potential to reduce Gnutella’s 
bandwidth requirements by orders of magnitude, achieving true scalability.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>However, query routing should be 
carefully studied in simulation before wider deployment.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<H2>Appendix A: Java Implementation of Hash Function</H2>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></SPAN></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt">/** <o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;</SPAN>* The 
official platform-independent hashing function for query-routing.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>The<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;</SPAN>* key 
property is that it allows interpolation of hash tables of 
different<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;</SPAN>* 
sizes.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>More formally 
k*hash(x,n)&lt;=hash(x, 
kn)&lt;=k*hash(x,n)+(k-1).&lt;p&gt;<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>*/<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt">public class HashFunction 
{<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>/** <o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>* A 32-bit integer 
version of the golden ratio, (sqrt(5)-1)/2, as suggested<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>* by 
Knuth.<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>*/<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>private static final int 
A_INT=0x4F1BBCDC;<o:p></o:p></SPAN></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; 
</SPAN>/**<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>* Returns the n-&lt;b&gt;bit&lt;/b&gt; hash of x.toLowerCase(), where 
n="bits".<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>That<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>* is, the returned value value can fit in "bits" unsigned bits, and 
is<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>* between 0 and (2^bits)-1.<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>*<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>* @param x the string to hash<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>* @param bits the number of bits to use in the resulting 
answer<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>* @return the hash value<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>*/<SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; 
</SPAN><o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>public static int 
hash(String x, byte bits) {<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>return hash(x, 0, x.length(), bits);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>}<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></SPAN></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; 
</SPAN>/**<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>* Returns the same value as hash(x.substring(start, end), 
bits),<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>* but tries to avoid allocations.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>Note that x is lower-cased<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>* when hashing.<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>*<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>* @param x the string to hash<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>* @param bits the number of bits to use in the resulting 
answer<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>* @param start the start offset of the substring to 
hash<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>* @param end just PAST the end of the substring to 
hash<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>* @return the hash value <o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>*/<SPAN style="mso-spacerun: yes">&nbsp;&nbsp; 
</SPAN><o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>public static int 
hash(String x, int start, int end, byte bits) {<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//1. 
First turn x[start...end-1] into a number by treating all 
4-byte<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//chunks as a little-endian quadword, and XOR'ing the result 
together.<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//We 
pad x with zeroes as needed. <o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//<SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>To avoid 
having do deal with special cases, we do this by XOR'ing<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//a 
rolling value one byte at a time, taking advantage of the fact 
that<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//x 
XOR 0==x.<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>int 
xor=0;<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>//the running 
total<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>int 
j=0;<SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//the byte 
position in xor.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>INVARIANT: 
j==(i-start)%4<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>for 
(int i=start; i&lt;end; i++) {<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>int b=Character.toLowerCase(x.charAt(i)) &amp; 0xFF; 
<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN>b=b&lt;&lt;(j*8);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>xor=xor^b;<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>j=(j+1)%4;<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//2. 
Now map number to range 0 - (2^bits-1).<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>return hashFast(xor, bits);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>}<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><I 
style="mso-bidi-font-style: normal"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>/**<o:p></o:p></I></SPAN></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>* Returns the n-&lt;b&gt;bit&lt;/b&gt; hash of x, where n="bits".<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>That is, the<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>* returned value value can fit in "bits" unsigned bits, and 
is<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>* between 0 and (2^bits)-1.<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>*/<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>private static int 
hashFast(int x, byte bits) {<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//Multiplication-based hash function.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>See Chapter 12.3.2. of 
CLR.<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>long 
prod= (long)x * (long)A_INT;<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>long 
ret= prod &lt;&lt; 32;<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>ret 
= ret &gt;&gt;&gt; (32 + (32 - bits));<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>return (int)ret;<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>}<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></SPAN></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; 
</SPAN>/** Unit tests. */<o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><I style="mso-bidi-font-style: normal"><SPAN 
style="FONT-SIZE: 8pt"><o:p></o:p></SPAN></I></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>public static void 
main(String args[]) {<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//1. 
Basic hash tests.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>These unit tests 
were generated by the reference<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//implementation of HashFunction.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>Some I've checked manually.<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("", (byte)13)==0);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("eb", (byte)13)==6791);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("ebc", (byte)13)==7082);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("ebck", (byte)13)==6698);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("ebckl", (byte)13)==3179);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("ebcklm", (byte)13)==3235);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("ebcklme", (byte)13)==6438);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("ebcklmen", (byte)13)==1062);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>Assert.that(hash("ebcklmenq", 
(byte)13)==3527);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("", (byte)16)==0);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("n", (byte)16)==65003);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("nd", (byte)16)==54193);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("ndf", (byte)16)==4953);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("ndfl", (byte)16)==58201);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("ndfla", (byte)16)==34830);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("ndflal", (byte)16)==36910);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("ndflale", (byte)16)==34586);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("ndflalem", (byte)16)==37658);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("ndflaleme", (byte)16)==45559);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("ol2j34lj", (byte)10)==318);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("asdfas23", (byte)10)==503);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("9um3o34fd", (byte)10)==758);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("a234d", (byte)10)==281);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("a3f", (byte)10)==767);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("3nja9", (byte)10)==581);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("2459345938032343", 
(byte)10)==146);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("7777a88a8a8a8", (byte)10)==342);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("asdfjklkj3k", (byte)10)==861);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("adfk32l", (byte)10)==1011);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("zzzzzzzzzzz", (byte)10)==944);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//2. 
Case tests.<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("3nja9", (byte)10)==581);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("3NJA9", (byte)10)==581);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Assert.that(hash("3nJa9", (byte)10)==581);<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>}<o:p></o:p></SPAN></P>
<P class=MsoPlainText><SPAN style="FONT-SIZE: 8pt">}<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN style="FONT-SIZE: 8pt; FONT-FAMILY: 'Courier New'"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></SPAN></P>
<H2>Appendix B: Patch Message Examples</H2>
<P class=MsoNormal><SPAN style="FONT-SIZE: 8pt; FONT-FAMILY: 'Courier New'"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></SPAN></P>
<P class=MsoNormal>Here are sample encoding of query route tables.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>These examples show the messages sent by 
a leaf node who initially shares a file named “test”, subsequently shares a file 
named “qrp”, then unshares the file named “test”.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Hence keywords are always added with a 
distance of one.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Each example 
conveys the same information, showing that table updates can be encoded multiple 
ways.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>For simplicity, the table is only 8 entries long.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>In all examples, INFINITY=7, though 
values as small as 2 could be used.&nbsp; All messages are given in symbolic 
form along with the raw bytes in hexadecimal, with "|" denoting the end of the 
23 byte Gnutella header.&nbsp;</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<H3>Example 1: BITS=8, no splitting or compression</H3>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal><I>Note that –6 is encoded in a single byte as 11111010 in 
binary, or “fa” in hexadecimal.</I></P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Initial encoding of table containing word "test" (hash=2)</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{RESET, tableSize: 8, Infinity: 
7}</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">85 d9 76 4d bf 2 1d 9a ff 72 e7 21 
c3 40 dd 0 30 1 0 6 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">0 8 0 0 0 7</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 1/1, Bits: 8, 
Compr: 0, [&lt;8 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">a9 ab 9b 14 c1 1e 52 aa ff b4 b4 
41 75 6d 29 0 30 1 0 d 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 1 1 0 8 0 0 fa 0 0 0 0 0</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Adding the word "qrp" (hash=7)</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 1/1, Bits: 8, 
Compr: 0, [&lt;8 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">d6 c4 b4 21 36 d0 ae 94 ff 56 7 e9 
58 dd 72 0 30 1 0 d 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 1 1 0 8 0 0 0 0 0 0 fa 0</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Removing "test"</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 1/1, Bits: 8, 
Compr: 0, [&lt;8 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">3a e4 59 89 ae 3b 67 8a ff 96 95 
66 e8 b2 b9 0 30 1 0 d 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 1 1 0 8 0 0 6 0 0 0 0 0</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<H3>Example 2: BITS=4, no splitting or compression</H3>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoBodyText>Note that –6 is encoded in a single nibble (half a byte) as 
1010 in binary, or “a” in hexadecimal.</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Initial encoding of table containing word "test" (hash=2)</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{RESET, tableSize: 8, Infinity: 
7}</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">3f 7c 5a 8c 14 8a 38 22 ff bf 3b 
76 5e 86 c6 0 30 1 0 6 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">0 8 0 0 0 7</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 1/1, Bits: 4, 
Compr: 0, [&lt;4 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">50 4a bb d7 c0 ea 68 68 ff ef 55 
65 31 2f 39 0 30 1 0 9 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 1 1 0 4 0 a0 0 0</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Adding the word "qrp" (hash=7)</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 1/1, Bits: 4, 
Compr: 0, [&lt;4 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">5d 34 5b 67 f3 60 e 9c ff bc 26 79 
5a 31 d2 0 30 1 0 9 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 1 1 0 4 0 0 0 a0</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Removing "test"</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 1/1, Bits: 4, 
Compr: 0, [&lt;4 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">f4 26 fa 2d b6 cc 23 7f ff ab 87 
ef 6f 3a 93 0 30 1 0 9 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 1 1 0 4 0 60 0 0</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<H3>Example 3: BITS=4, splitting, no compression</H3>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal><I>Splitting is waste of bandwidth with such small tables, 
but it demonstrates how the protocol works with larger 
tables.<o:p></o:p></I></P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Initial encoding of table containing word "test" (hash=2)</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{RESET, tableSize: 8, Infinity: 
7}</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">7e a1 67 2f 86 3b 9 8b ff a2 cd 26 
88 4d 84 0 30 1 0 6 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">0 8 0 0 0 7</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 1/2, Bits: 4, 
Compr: 0, [&lt;2 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">a0 71 1 1f b1 e7 9e 63 ff f0 8a 60 
c0 5a c 0 30 1 0 7 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 1 2 0 4 0 a0</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 2/2, Bits: 4, 
Compr: 0, [&lt;2 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">d 1b e6 71 eb 26 9c f ff 10 60 7f 
31 72 41 0 30 1 0 7 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 2 2 0 4 0 0</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Adding the word "qrp" (hash=7)</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 1/2, Bits: 4, 
Compr: 0, [&lt;2 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">c7 ed 3d ca 3e ab 1d 5e ff e8 d6 5 
1b 71 f6 0 30 1 0 7 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 1 2 0 4 0 0</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 2/2, Bits: 4, 
Compr: 0, [&lt;2 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">10 28 ad 5c fb 37 ba 4e ff 6b 38 
a0 e2 1d d4 0 30 1 0 7 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 2 2 0 4 0 a0</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Removing "test"</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 1/2, Bits: 4, 
Compr: 0, [&lt;2 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">40 11 74 1d ff 85 b8 b3 ff 95 58 0 
ee 6f de 0 30 1 0 7 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 1 2 0 4 0 60</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 2/2, Bits: 4, 
Compr: 0, [&lt;2 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">d8 6d f5 d1 38 a8 8 cf ff 20 c9 eb 
d2 f1 2b 0 30 1 0 7 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 2 2 0 4 0 0</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<H3>Example 4: BITS=4, no splitting, compression</H3>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal><I>Compression is a waste of bandwidth with such small 
tables, but it demonstrates how the protocol works with larger tables.</I></P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Initial encoding of table containing word "test" (hash=2)</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{RESET, tableSize: 8, Infinity: 
7}</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">71 9f 38 68 49 c0 96 45 ff 23 ae 
12 2 cd b3 0 30 1 0 6 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">0 8 0 0 0 7</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 1/1, Bits: 4, 
Compr: 1, [&lt;12 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">f1 a9 21 cf 47 75 9f 50 ff 8 f1 f3 
57 d9 c3 0 30 1 0 11 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 1 1 1 4 78 9c 63 58 c0 c0 0 0 1 
e4 0 a1</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Adding the word "qrp" (hash=7)</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 1/1, Bits: 4, 
Compr: 1, [&lt;12 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">fe 8 b5 ed a fb e7 88 ff d8 4d 6 
af b 11 0 30 1 0 11 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 1 1 1 4 78 9c 63 60 60 58 0 0 0 
a4 0 a1</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Removing "test"</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 1/1, Bits: 4, 
Compr: 1, [&lt;12 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">5a 23 fc 3d 27 d0 b1 17 ff b 92 c6 
a2 af 1f 0 30 1 0 11 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 1 1 1 4 78 9c 63 48 60 60 0 0 1 
24 0 61</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<H3>Example 5: BITS=4, splitting and compression</H3>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Initial encoding of table containing word "test" (hash=2)</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{RESET, tableSize: 8, Infinity: 
7}</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">2a c8 2f 10 90 1c a7 1e ff 14 6c 
12 71 9f b7 0 30 1 0 6 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">0 8 0 0 0 7</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 1/2, Bits: 4, 
Compr: 1, [&lt;10 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1f 6c dc 54 ac 1f 42 cc ff 31 99 
15 a0 e0 36 0 30 1 0 f 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 1 2 1 4 78 9c 63 58 c0 c0 0 0 1 
e4</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 2/2, Bits: 4, 
Compr: 1, [&lt;2 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">c1 c0 1a 79 2e 32 6e 54 ff e7 8d 
21 de 4 3c 0 30 1 0 7 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 2 2 1 4 0 a1</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Adding the word "qrp" (hash=7)</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 1/2, Bits: 4, 
Compr: 1, [&lt;10 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">63 79 60 3 36 4f dd 86 ff a1 84 c4 
dd d6 c7 0 30 1 0 f 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 1 2 1 4 78 9c 63 60 60 58 0 0 0 
a4</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 2/2, Bits: 4, 
Compr: 1, [&lt;2 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">6d 93 7 a0 73 14 1b 69 ff 62 66 ba 
56 47 10 0 30 1 0 7 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 2 2 1 4 0 a1</P>
<P class=MsoNormal><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>Removing "test"</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 1/2, Bits: 4, 
Compr: 1, [&lt;10 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">70 da 77 93 a2 f6 53 39 ff 5f e7 
fa 2c 1f c2 0 30 1 0 f 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 1 2 1 4 78 9c 63 48 60 60 0 0 1 
24</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in"><![if !supportEmptyParas]><![endif]>&nbsp;<o:p></o:p></P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">{PATCH, Sequence: 2/2, Bits: 4, 
Compr: 1, [&lt;2 bytes&gt;]</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">7a 19 5c b6 54 ba bc ec ff 4e 3d 
c5 d1 2f a9 0 30 1 0 7 0 0 0 |</P>
<P class=MsoNormal style="MARGIN-LEFT: 0.5in">1 2 2 1 4 0 61</P></DIV>
<DIV style="mso-element: footnote-list"><![if !supportFootnotes]><BR clear=all>
<HR align=left width="33%" SIZE=1>
<![endif]>
<DIV id=ftn1 style="mso-element: footnote">
<P class=MsoFootnoteText><A title="" style="mso-footnote-id: ftn1" name=_ftn1 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftnref1"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[1]<![endif]></SPAN></SPAN></A> 
Generally speaking, it is better to propagate keywords than full filenames.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>First, it generally saves bandwidth when 
propagating tables.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>For example the 
files “good book” and “bad book” can be compressed into the keyword set {“good”, 
“bad”, “book”}.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Secondly, it makes 
query processing easier, since hosts don’t need<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>to check whether a query is a 
<I>substring</I> of each filename.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>Finally, this scheme allows hosts greater flexibility in query 
responses.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>For example, it allows a 
host to match queries with the <I>contents</I> of a file—not just its name—if it 
desires.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN></P></DIV>
<DIV id=ftn2 style="mso-element: footnote">
<P class=MsoFootnoteText><A title="" style="mso-footnote-id: ftn2" name=_ftn2 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftnref2"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[2]<![endif]></SPAN></SPAN></A> 
Logically OR’ing bitmaps is analogous to unioning sets of keywords.</P></DIV>
<DIV id=ftn3 style="mso-element: footnote">
<P class=MsoFootnoteText><A title="" style="mso-footnote-id: ftn3" name=_ftn3 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftnref3"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[3]<![endif]></SPAN></SPAN></A> 
This is similar to the improved horizon counting algorithm described by Rohrs 
<SUP><SPAN 
style="FONT-FAMILY: 'TIMES NEW \(W1\)'; mso-bidi-font-family: 'Times New Roman'">[Roh]</SPAN></SUP><SPAN 
style="FONT-FAMILY: 'TIMES NEW \(W1\)'; mso-bidi-font-family: 'Times New Roman'">.</SPAN></P></DIV>
<DIV id=ftn4 style="mso-element: footnote">
<P class=MsoFootnoteText><A title="" style="mso-footnote-id: ftn4" name=_ftn4 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftnref4"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[4]<![endif]></SPAN></SPAN></A> 
Intuitively, one expects more files available at N+1 hops than N hops, since a 
query of TTL N+1 can search a much larger horizon.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Hence smaller hops values should be much 
less common than large hop values in our routing tables.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Statistical compression schemes such as 
Huffman encodings take advantage of precisely this.</P></DIV>
<DIV id=ftn5 style="mso-element: footnote">
<P class=MsoFootnoteText><A title="" style="mso-footnote-id: ftn5" name=_ftn5 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftnref5"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[5]<![endif]></SPAN></SPAN></A> 
An original draft of our protocol had separate sparse and dense update messages 
for use with different kinds of route tables, as suggested by Prinkey.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Now such distinctions are not needed; 
the compression scheme relieves us of this burden.</P></DIV>
<DIV id=ftn6 style="mso-element: footnote">
<P class=MsoFootnoteText><A title="" style="mso-footnote-id: ftn6" name=_ftn6 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftnref6"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[6]<![endif]></SPAN></SPAN></A>A 
study of 300 connections over several days showed that the average uptime of a 
connection was 24 minutes.<SPAN style="mso-spacerun: yes">&nbsp;&nbsp; 
</SPAN>The average uptime of a connection surviving 1 minute was 88 
minutes.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>The average uptime of a 
connection surviving 5 minutes was 133 minutes—more than two hours.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>So the longer a connection is up, the 
longer one can expect it to remain up.</P></DIV>
<DIV id=ftn7 style="mso-element: footnote">
<P class=MsoFootnoteText><A title="" style="mso-footnote-id: ftn7" name=_ftn7 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftnref7"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[7]<![endif]></SPAN></SPAN></A> 
An alternative is for RESET messages to initialize the receiver’s route table to 
be a completely full route table, i.e., one for which all elements are 0.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Then no special rules are needed when 
forwarding queries.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>The problem is 
that the client must not propagate the RESET’ed route table along other 
connections until the last PATCH message has been received.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Doing so would quickly flood the network 
with full tables, making query routing useless.</P></DIV>
<DIV id=ftn8 style="mso-element: footnote">
<P class=MsoFootnoteText><A title="" style="mso-footnote-id: ftn8" name=_ftn8 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftnref8"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[8]<![endif]></SPAN></SPAN></A> 
Flow control schemes should make sure that route table messages are never 
dropped.</P></DIV>
<DIV id=ftn9 style="mso-element: footnote">
<P class=MsoFootnoteText><A title="" style="mso-footnote-id: ftn9" name=_ftn9 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftnref9"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[9]<![endif]></SPAN></SPAN></A> 
Revision 0.1 of our proposal used GZIP instead of ZLIB.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>GZIP uses ZLIB internally but also adds 
a header and checksum.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Hence using 
ZLIB saves a few bytes.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>We also 
found Java’s support for ZLIB to be better than its support for GZIP.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>C programmers can use the zlib library 
to create and read ZLIB data.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>Revision 0.3 of this document mistakenly referred to the “DEFLATE” 
algorithm instead of ZLIB.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>While 
the two are related, they are not identical.</P></DIV>
<DIV id=ftn10 style="mso-element: footnote">
<P class=MsoFootnoteText><A title="" style="mso-footnote-id: ftn10" name=_ftn10 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ftnref10"><SPAN 
class=MsoFootnoteReference><SPAN style="mso-special-character: footnote"><![if !supportFootnotes]>[10]<![endif]></SPAN></SPAN></A> 
All “modern” Gnutella clients use marked GUIDs for identification purposes.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>The ninth byte of these GUIDs (guid[8]) 
is all 1’s to distinguish them from the Gnutella 0.56 client.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>The last byte is a version number to 
allow Gnutella protocol versioning.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>The current version number is 0.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>The remaining bytes are typically random, though this is not 
required.</P></DIV></DIV>
<DIV style="mso-element: endnote-list"><![if !supportEndnotes]><BR clear=all>
<HR align=left width="33%" SIZE=1>
<![endif]>
<DIV id=edn1 style="mso-element: endnote">
<P class=MsoEndnoteText><A title="" style="mso-endnote-id: edn1" name=_edn1 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ednref1"><SPAN 
class=MsoEndnoteReference>[Sin]</SPAN></A> Singla, Anurag and Christopher 
Rohrs.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN><I>Ultrapeers: Another Step 
Towards Gnutella Scalability</I>.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN><SPAN 
class=MsoHyperlink>http://groups.yahoo.com/group/the_gdf/files/Proposals/Ultrapeer/Ultrapeers.html</SPAN></P></DIV>
<DIV id=edn2 style="mso-element: endnote">
<P class=MsoEndnoteText><A title="" style="mso-endnote-id: edn2" name=_edn2 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ednref2"><SPAN 
class=MsoEndnoteReference>[Bil]</SPAN></A> Bildson, Greg.<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><I>Gnutella: Settings the Record 
Straight.</I><SPAN style="mso-spacerun: yes">&nbsp; </SPAN><A 
href="http://www.limewire.com/index.jsp/setting_record">http://www.limewire.com/index.jsp/setting_record</A>.</P></DIV>
<DIV id=edn3 style="mso-element: endnote">
<P class=MsoEndnoteText><A title="" style="mso-endnote-id: edn3" name=_edn3 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ednref3"><SPAN 
class=MsoEndnoteReference>[Lan]</SPAN></A> Langley, Adam.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>“Freenet.”<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><I>Peer-to-Peer: Harnessing the Power of 
Disruptive Technologies</I>.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Ed. 
Andy Oram.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>O’Reilly, 2001.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>123-132.</P></DIV>
<DIV id=edn4 style="mso-element: endnote">
<P class=MsoEndnoteText><A title="" style="mso-endnote-id: edn4" name=_edn4 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ednref4"><SPAN 
class=MsoEndnoteReference>[</SPAN></A><SPAN class=MsoEndnoteReference><SPAN 
style="FONT-FAMILY: 'TIMES NEW \(W1\)'; mso-bidi-font-family: 'Times New Roman'">Pri</SPAN>]</SPAN> 
Prinkey, Michael T.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN><I>An Efficient 
Scheme for Query Processing on Peer-to-Peer Networks</I> <SPAN 
class=MsoHyperlink><A 
href="http://aeolusres.homestead.com/files/index.html">http://aeolusres.homestead.com/files/index.html</A></SPAN>.</P>
<P class=MsoEndnoteText><SUP><SPAN 
style="FONT-FAMILY: 'TIMES NEW \(W1\)'; mso-bidi-font-family: 'Times New Roman'">[Roh]</SPAN></SUP> 
Rohrs, Christopher.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN><I>Improving 
Gnutella’s Ping/Pong Scheme.</I> <A 
href="http://www.limewire.com/index.jsp/pingpong">http://www.limewire.com/index.jsp/pingpong</A>.<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN></P></DIV>
<DIV id=edn5 style="mso-element: endnote">
<P class=MsoEndnoteText><A title="" style="mso-endnote-id: edn5" name=_edn5 
href="http://www.limewire.com/developer/query_routing/keyword%20routing.htm#_ednref5"><SPAN 
class=MsoEndnoteReference>[Bil2]</SPAN></A> Bildson, Greg and Christopher 
Rohrs.<SPAN style="mso-spacerun: yes">&nbsp; </SPAN><I>An Extensible Handshaking 
Protocol for the Gnutella Network</I>.<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN><SPAN 
class=MsoHyperlink>http://groups.yahoo.com/group/the_gdf/files/Development/Gnutella%200.6%20Handshaking%20Protocol</SPAN></P></DIV></DIV></BODY></HTML>
